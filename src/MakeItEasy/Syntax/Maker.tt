<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
namespace MakeItEasy.Syntax
{
    using System;
    using MakeItEasy.Internal;

    /// <summary>
    /// A helper class for creating systems under test. Typically there would be no need to access this
    /// class directly form outside the library.
    /// </summary>
    /// <typeparam name="T">The type of object to create.</typeparam>
    public sealed class Maker<T>
    {
<# GenerateMethods(); #>
        private static T Create(Type[] argumentTypes, object?[] argumentValues, Type[] collaboratorTypes, out object[] collaboratorValues)
        {
            return SubjectBuilder.BuildSubject<T>(argumentTypes, argumentValues, collaboratorTypes, out collaboratorValues);
        }
    }
}
#nullable disable
<#+
void GenerateMethods()
{
    for (int numberOfArguments = 0; numberOfArguments <= 8; ++numberOfArguments)
    {
        for (int numberOfCollaborators = 0; numberOfCollaborators <= 8; ++numberOfCollaborators)
        {
            GenerateOneFromMethod(numberOfArguments, numberOfCollaborators);
        }
    }
}
#>

<#+
void GenerateOneFromMethod(int numberOfArguments, int numberOfCollaborators)
{
#>
        /// <summary>
        /// Creates an object of type <typeparamref name="T"/>. One use for this object would be as the
        /// System Under Test for some test.
        /// </summary>
        /// <returns>The desired object.</returns>
<#+
for (int i = 1; i <= numberOfArguments; ++i)
{
#>
        /// <typeparam name="TArg<#= i #>">The type of argument<#= i #>.</typeparam>
        /// <param name="argument<#= i #>">Argument <#= i #> to be used in the object constructor.</param>");
<#+
}
for (int i = 1; i <= numberOfCollaborators; ++i)
{
#>
        /// <typeparam name="TCollab<#= i #>">The type of <paramref name="collaborator<#= i #>"/> to return.</typeparam>
        /// <param name="collaborator<#= i #>">Will be filled with a Fake TCollab<#= i #> collaborator used to create the object.</param>
<#+
}

var typeParams = numberOfArguments + numberOfCollaborators == 0
    ? string.Empty
    : '<' + string.Join(", ", Enumerable.Range(1, numberOfArguments).Select(i => "TArg" + i).Concat(Enumerable.Range(1, numberOfCollaborators).Select(i => "TCollab" + i))) + '>';
var arguments = numberOfArguments + numberOfCollaborators == 0
    ? string.Empty
    : string.Join(", ", Enumerable.Range(1, numberOfArguments).Select(i => $"TArg{i} argument{i}").Concat(Enumerable.Range(1, numberOfCollaborators).Select(i => $"out TCollab{i} collaborator{i}")));
var typeParamsConstraints = numberOfCollaborators == 0
    ? string.Empty
    : string.Join(" ", Enumerable.Range(1, numberOfCollaborators).Select(i => $"where TCollab{i} : class"));
var argumentTypesArray = numberOfArguments == 0
    ? "Type.EmptyTypes"
    : "new[] { " + string.Join(", ", Enumerable.Range(1, numberOfArguments).Select(i => $"typeof(TArg{i})")) + " }";
var argumentValuesArray = numberOfArguments == 0
    ? "new object?[0]"
    : "new object?[] { " + string.Join(", ", Enumerable.Range(1, numberOfArguments).Select(i => $"argument{i}")) + " }";
var collaboratorTypesArray = numberOfCollaborators == 0
    ? "Type.EmptyTypes"
    : "new[] { " + string.Join(", ", Enumerable.Range(1, numberOfCollaborators).Select(i => $"typeof(TCollab{i})")) + " }";
#>
        public T From<#= typeParams #>(<#= arguments #>)
        {
            var subject = Create(
                <#= argumentTypesArray #>,
                <#= argumentValuesArray #>,
                <#= collaboratorTypesArray #>,
                out object[] collaborators);
<#+
for (int i = 1; i <= numberOfCollaborators; ++i)
{
#>
            collaborator<#= i #> = (TCollab<#= i #>)collaborators[<#= i - 1 #>];
<#+
}
#>
            return subject;
        }

<#+
}
#>
